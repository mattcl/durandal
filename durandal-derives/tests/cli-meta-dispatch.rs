use anyhow::Result;
use clap::{Parser, Subcommand, Args};
use durandal_core::CliMetaCommand;
use durandal_derives::CliMetaDispatch;

pub struct FakeConfig {}

#[derive(Parser)]
#[clap(name = "cli-dispatch-test")]
pub struct Cli {
    #[clap(subcommand)]
    pub command: Commands,
}

impl Cli {
    pub fn run(meta: &FakeConfig) -> Result<()> {
        // We expect the dispatch to run be generated by the CliDispatch derive
        Self::parse().command.run(meta)
    }
}


#[derive(Subcommand, CliMetaDispatch)]
#[cli_meta(FakeConfig)]
pub enum Commands {
    Foo(Foo),
    Bar(Foo),

    // I'd like to test this, but it relies on a crate name. Particularly the
    // crate_name! macro from clap. So I guess we have to figure that out.
    // #[clap(external_subcommand)]
    // External(Vec<String>),
}

#[derive(Args)]
pub struct Foo { }

impl CliMetaCommand for Foo {
    type Meta = FakeConfig;

    fn run(&self, _meta: &Self::Meta) -> anyhow::Result<()> {
        Ok(())
    }
}

fn main() {}
